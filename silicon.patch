diff --git a/src/main/scala/Config.scala b/src/main/scala/Config.scala
index ea512c89..fbb73f7a 100644
--- a/src/main/scala/Config.scala
+++ b/src/main/scala/Config.scala
@@ -571,19 +571,6 @@ class Config(args: Seq[String]) extends SilFrontendConfig(args, "Silicon") {
     case _ => Right(())
   }
 
-  validateOpt(ideModeAdvanced, numberOfParallelVerifiers) {
-    case (Some(false), _) =>
-      Right(())
-    case (Some(true), Some(n)) =>
-      if (n == 1)
-        Right(())
-      else
-        Left(  s"Option ${ideModeAdvanced.name} requires setting "
-             + s"${numberOfParallelVerifiers.name} to 1")
-    case other =>
-      sys.error(s"Unexpected combination: $other")
-  }
-
   validateFileOpt(logConfig)
   validateFileOpt(setAxiomatizationFile)
   validateFileOpt(multisetAxiomatizationFile)
diff --git a/src/main/scala/Silicon.scala b/src/main/scala/Silicon.scala
index 94e99361..d656fd00 100644
--- a/src/main/scala/Silicon.scala
+++ b/src/main/scala/Silicon.scala
@@ -213,7 +213,7 @@ class Silicon(val reporter: Reporter, private var debugInfo: Seq[(String, Any)]
           // verification was interrupted, therefore close the current member's scope:
           SymbExLogger.currentLog().closeMemberScope()
           if (config.ideModeAdvanced()) {
-            reporter report ExecutionTraceReport(SymbExLogger.memberList, List(), List())
+            reporter report ExecutionTraceReport(SymbExLogger.memberList.toIndexedSeq, List(), List())
           }
           result = Some(SilFailure(SilTimeoutOccurred(config.timeout(), "second(s)") :: Nil))
         case exception: Exception if !config.disableCatchingExceptions() =>
diff --git a/src/main/scala/logger/LogConfig.scala b/src/main/scala/logger/LogConfig.scala
index ae391443..dd7d635e 100644
--- a/src/main/scala/logger/LogConfig.scala
+++ b/src/main/scala/logger/LogConfig.scala
@@ -7,10 +7,23 @@
 package viper.silicon.logger
 
 import spray.json._
+import viper.silicon.logger.records.data.DataRecord
 
 case class LogConfig(isBlackList: Boolean,
                      includeStore: Boolean, includeHeap: Boolean, includeOldHeap: Boolean, includePcs: Boolean,
-                     recordConfigs: List[RecordConfig])
+                     recordConfigs: List[RecordConfig]) {
+  def getRecordConfig(d: DataRecord): Option[RecordConfig] = {
+    for (rc <- recordConfigs) {
+      if (rc.kind.equals(d.toTypeString)) {
+        rc.value match {
+          case Some(value) => if (value.equals(d.toSimpleString)) return Some(rc)
+          case _ => return Some(rc)
+        }
+      }
+    }
+    None
+  }
+}
 
 object LogConfig {
   def default(): LogConfig = LogConfig(
diff --git a/src/main/scala/logger/SymbExLogger.scala b/src/main/scala/logger/SymbExLogger.scala
index b07526b5..a277bb62 100644
--- a/src/main/scala/logger/SymbExLogger.scala
+++ b/src/main/scala/logger/SymbExLogger.scala
@@ -7,25 +7,26 @@
 package viper.silicon.logger
 
 import java.nio.file.{Files, Path, Paths}
-
 import spray.json._
 import LogConfigProtocol._
 import com.typesafe.scalalogging.Logger
 import org.slf4j.LoggerFactory
 import viper.silicon.decider.PathConditionStack
-import viper.silicon.logger.SymbExLogger.getRecordConfig
 import viper.silicon.logger.records.SymbolicRecord
 import viper.silicon.logger.records.data.{DataRecord, FunctionRecord, MemberRecord, MethodRecord, PredicateRecord}
 import viper.silicon.logger.records.scoping.{CloseScopeRecord, OpenScopeRecord, ScopingRecord}
-import viper.silicon.logger.records.structural.BranchingRecord
+import viper.silicon.logger.records.structural.{BranchingRecord, StructuralRecord}
 import viper.silicon.logger.renderer.SimpleTreeRenderer
 import viper.silicon.state._
 import viper.silicon.state.terms._
 import viper.silicon.{Config, Map}
 import viper.silver.ast
+import viper.silver.ast.Exp
 
+import java.util.concurrent.atomic.AtomicInteger
 import scala.annotation.elidable
 import scala.annotation.elidable._
+import scala.collection.mutable.ArrayBuffer
 import scala.util.{Failure, Success, Try}
 
 /* TODO: InsertionOrderedSet is used by the logger, but the insertion order is
@@ -37,8 +38,7 @@ import scala.util.{Failure, Success, Try}
   * ================================
   * SymbExLogger Usage
   * ================================
-  * The SymbExLogger has to be enabled by passing `--ideModeAdvanced` to Silicon (which in turn
-  * requires numberOfParallelVerifiers to be 1).
+  * The SymbExLogger has to be enabled by passing `--ideModeAdvanced` to Silicon.
   * Unless otherwise specified, the default logConfig will be used (viper.silicon.logger.LogConfig.default()):
   * All logged records will be included in the report, but store, heap, and path conditions will be omitted.
   *
@@ -194,29 +194,16 @@ import scala.util.{Failure, Success, Try}
 
 object SymbExLogger {
   /** Collection of logged Method/Predicates/Functions. **/
-  var memberList: Seq[SymbLog] = Seq[SymbLog]()
-  private var uidCounter = 0
+  val memberList: ArrayBuffer[SymbLog] = ArrayBuffer()
+  var _currentLog: ThreadLocal[Option[SymbLog]] = ThreadLocal.withInitial(() => None)
+
+  private val uidCounter = new AtomicInteger(0)
 
   var enabled = false
   var logConfig: LogConfig = LogConfig.default()
+  var listenerProvider: LogConfig => SymbLogListener = new InMemorySymbLog(_)
 
-  def freshUid(): Int = {
-    val uid = uidCounter
-    uidCounter = uidCounter + 1
-    uid
-  }
-
-  def getRecordConfig(d: DataRecord): Option[RecordConfig] = {
-    for (rc <- logConfig.recordConfigs) {
-      if (rc.kind.equals(d.toTypeString)) {
-        rc.value match {
-          case Some(value) => if (value.equals(d.toSimpleString)) return Some(rc)
-          case _ => return Some(rc)
-        }
-      }
-    }
-    None
-  }
+  def freshUid(): Int = uidCounter.getAndIncrement()
 
   /**
     * stores the last SMT solver statistics to calculate the diff
@@ -233,7 +220,9 @@ object SymbExLogger {
     */
   @elidable(INFO)
   def openMemberScope(member: ast.Member, s: State, pcs: PathConditionStack): Unit = {
-    memberList = memberList ++ Seq(new SymbLog(member, s, pcs))
+    val log = new SymbLog(listenerProvider(logConfig), member, s, pcs)
+    memberList.synchronized { memberList += log }
+    _currentLog.set(Some(log))
   }
 
   /** Use this method to access the current log, e.g., to access the log of the method
@@ -243,7 +232,7 @@ object SymbExLogger {
     */
   def currentLog(): SymbLog = {
     if (enabled)
-      memberList.last
+      _currentLog.get.get
     else NoopSymbLog
   }
 
@@ -251,6 +240,7 @@ object SymbExLogger {
   def closeMemberScope(): Unit = {
     if (enabled) {
       currentLog().closeMemberScope()
+      _currentLog.set(None)
     }
   }
 
@@ -264,6 +254,9 @@ object SymbExLogger {
     logConfig = parseLogConfig(c)
   }
 
+  def setListenerProvider(listener: LogConfig => SymbLogListener): Unit =
+    listenerProvider = listener
+
   @elidable(INFO)
   private def setEnabled(b: Boolean): Unit = {
     enabled = b
@@ -288,7 +281,7 @@ object SymbExLogger {
   def toSimpleTreeString: String = {
     if (enabled) {
       val simpleTreeRenderer = new SimpleTreeRenderer()
-      simpleTreeRenderer.render(memberList)
+      simpleTreeRenderer.render(memberList.map(_.listener).collect { case l: InMemorySymbLog => l })
     } else ""
   }
 
@@ -300,15 +293,16 @@ object SymbExLogger {
     * Only needed when several files are verified together (e.g., sbt test).
     */
   def reset(): Unit = {
-    memberList = Seq[SymbLog]()
-    uidCounter = 0
+    memberList.clear()
+    uidCounter.set(0)
     filePath = null
     logConfig = LogConfig.default()
+    listenerProvider = new InMemorySymbLog(_)
     prevSmtStatistics = new Map()
   }
 
   def resetMemberList(): Unit = {
-    memberList = Seq[SymbLog]()
+    memberList.clear()
     // or reset by calling it from Decider.reset
     prevSmtStatistics = new Map()
   }
@@ -350,25 +344,97 @@ object SymbExLogger {
 
 //========================= SymbLog ========================
 
-/**
-  * Concept: One object of SymbLog per Method/Predicate/Function. SymbLog
-  * is used in the SymbExLogger-object.
-  */
-class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
+trait SymbLogListener {
+  def appendDataRecord(symbLog: SymbLog, r: DataRecord): Unit
+  def appendScopingRecord(symbLog: SymbLog, r: ScopingRecord, ignoreBranchingStack: Boolean = false): Unit
+  def appendBranchingRecord(symbLog: SymbLog, r: BranchingRecord): Unit
 
-  val logger: Logger =
-    Logger(LoggerFactory.getLogger(s"${this.getClass.getName}"))
+  def switchToNextBranch(symbLog: SymbLog, uidBranchPoint: Int): Unit
+  def markBranchReachable(symbLog: SymbLog, uidBranchPoint: Int): Unit
+  def endBranchPoint(symbLog: SymbLog, uidBranchPoint: Int): Unit
+}
 
+class InMemorySymbLog(config: LogConfig) extends SymbLogListener {
   /** top level log entries for this member; these log entries were recorded consecutively without branching;
-    * in case branching occured, one of these records is a BranchingRecord with all branches as field attached to it */
+   * in case branching occured, one of these records is a BranchingRecord with all branches as field attached to it */
   var log: Vector[SymbolicRecord] = Vector[SymbolicRecord]()
+
   /** this stack keeps track of BranchingRecords while adding records to the log; as soon as all branches of a
-    * BranchingRecord are done, logging has to switch back to the previous BranchingRecord */
+   * BranchingRecord are done, logging has to switch back to the previous BranchingRecord */
   var branchingStack: List[BranchingRecord] = List[BranchingRecord]()
+
   /** if a record was ignored due to the logConfig, its ID is tracked here and corresponding open and close scope
-    * records will be ignored too */
+   * records will be ignored too */
   var ignoredDataRecords: Set[Int] = Set()
 
+  def appendRecord(r: SymbolicRecord, ignoreBranchingStack: Boolean = false): Unit = {
+    if (branchingStack.isEmpty || ignoreBranchingStack) {
+      log = log :+ r
+    } else {
+      branchingStack.head.appendLog(r)
+    }
+  }
+
+  override def appendDataRecord(symbLog: SymbLog, r: DataRecord): Unit = {
+    val shouldIgnore = config.getRecordConfig(r) match {
+      case Some(_) => config.isBlackList
+      case None => !config.isBlackList
+    }
+
+    if(shouldIgnore) {
+      ignoredDataRecords = ignoredDataRecords + r.id
+    } else {
+      appendRecord(r)
+    }
+  }
+
+  override def appendScopingRecord(symbLog: SymbLog, r: ScopingRecord, ignoreBranchingStack: Boolean): Unit = {
+    if(!ignoredDataRecords.contains(r.refId)) {
+      if(ignoreBranchingStack) {
+        log = log :+ r
+      } else {
+        appendRecord(r)
+      }
+    }
+  }
+
+  override def appendBranchingRecord(symbLog: SymbLog, r: BranchingRecord): Unit = {
+    appendRecord(r)
+    branchingStack +:= r
+  }
+
+  override def switchToNextBranch(symbLog: SymbLog, uidBranchPoint: Int): Unit = {
+    assert(branchingStack.nonEmpty)
+    val branchingRecord = branchingStack.head
+    assert(branchingRecord.id == uidBranchPoint)
+    // no close scope is inserted because branches are not considered scopes
+    branchingRecord.switchToNextBranch()
+  }
+
+  override def markBranchReachable(symbLog: SymbLog, uidBranchPoint: Int): Unit = {
+    assert(branchingStack.nonEmpty)
+    val branchingRecord = branchingStack.head
+    assert(branchingRecord.id == uidBranchPoint)
+    branchingRecord.markReachable()
+  }
+
+  override def endBranchPoint(symbLog: SymbLog, uidBranchPoint: Int): Unit = {
+    assert(branchingStack.nonEmpty)
+    val branchingRecord = branchingStack.head
+    assert(branchingRecord.id == uidBranchPoint)
+    // no close scope is inserted because branches are not considered scopes
+    branchingStack = branchingStack.tail
+  }
+}
+
+/**
+  * Concept: One object of SymbLog per Method/Predicate/Function. SymbLog
+  * is used in the SymbExLogger-object.
+  */
+class SymbLog(val listener: SymbLogListener, val v: ast.Member, val s: State, val pcs: PathConditionStack) {
+  val logger: Logger =
+    Logger(LoggerFactory.getLogger(s"${this.getClass.getName}"))
+
   /**
     * indicates whether this member's close was already closed
     */
@@ -383,19 +449,8 @@ class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
     case f: ast.Function => new FunctionRecord(f, s, pcs)
     case _ => null
   }
-  openScope(main)
 
-  private def appendLog(r: SymbolicRecord, ignoreBranchingStack: Boolean = false): Unit = {
-    if (isClosed) {
-      logger warn "ignoring record insertion to an already closed SymbLog instance"
-      return
-    }
-    if (branchingStack.isEmpty || ignoreBranchingStack) {
-      log = log :+ r
-    } else {
-      branchingStack.head.appendLog(r)
-    }
-  }
+  openScope(main)
 
   /**
     * Inserts the record as well as a corresponding open scope record into the log
@@ -405,19 +460,8 @@ class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
   @elidable(INFO)
   def openScope(s: DataRecord): Int = {
     s.id = SymbExLogger.freshUid()
-    // check whether this record should be ignored:
-    val recordConfig = getRecordConfig(s)
-    val ignore = recordConfig match {
-      case Some(_) => SymbExLogger.logConfig.isBlackList
-      case _ => !SymbExLogger.logConfig.isBlackList
-    }
-    if (ignore) {
-      ignoredDataRecords = ignoredDataRecords + s.id
-    } else {
-      appendLog(s)
-      val openRecord = new OpenScopeRecord(s)
-      insert(openRecord)
-    }
+    listener.appendDataRecord(this, s)
+    insert(new OpenScopeRecord(s))
     s.id
   }
 
@@ -430,11 +474,8 @@ class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
   @elidable(INFO)
   private def insert(s: ScopingRecord, ignoreBranchingStack: Boolean = false): Int = {
     s.id = SymbExLogger.freshUid()
-    if (!ignoredDataRecords.contains(s.refId)) {
-      // the corresponding data record is not ignored
-      s.timeMs = System.currentTimeMillis()
-      appendLog(s, ignoreBranchingStack)
-    }
+    s.timeMs = System.currentTimeMillis()
+    listener.appendScopingRecord(this, s, ignoreBranchingStack)
     s.id
   }
 
@@ -447,11 +488,10 @@ class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
     * @return id of the branching record
     */
   @elidable(INFO)
-  def insertBranchPoint(possibleBranchesCount: Int, condition: Option[Term] = None): Int = {
-    val branchingRecord = new BranchingRecord(possibleBranchesCount, condition)
+  def insertBranchPoint(possibleBranchesCount: Int, condition: Option[Term] = None, conditionExp: Option[Exp] = None): Int = {
+    val branchingRecord = new BranchingRecord(possibleBranchesCount, condition, conditionExp)
     branchingRecord.id = SymbExLogger.freshUid()
-    appendLog(branchingRecord)
-    branchingStack = branchingRecord :: branchingStack
+    listener.appendBranchingRecord(this, branchingRecord)
     branchingRecord.id
   }
 
@@ -461,11 +501,7 @@ class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
     */
   @elidable(INFO)
   def switchToNextBranch(uidBranchPoint: Int): Unit = {
-    assert(branchingStack.nonEmpty)
-    val branchingRecord = branchingStack.head
-    assert(branchingRecord.id == uidBranchPoint)
-    // no close scope is inserted because branches are not considered scopes
-    branchingRecord.switchToNextBranch()
+    listener.switchToNextBranch(this, uidBranchPoint)
   }
 
   /**
@@ -474,10 +510,7 @@ class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
     */
   @elidable(INFO)
   def markReachable(uidBranchPoint: Int): Unit = {
-    assert(branchingStack.nonEmpty)
-    val branchingRecord = branchingStack.head
-    assert(branchingRecord.id == uidBranchPoint)
-    branchingRecord.markReachable()
+    listener.markBranchReachable(this, uidBranchPoint)
   }
 
   /**
@@ -496,11 +529,7 @@ class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
     */
   @elidable(INFO)
   def endBranchPoint(uidBranchPoint: Int): Unit = {
-    assert(branchingStack.nonEmpty)
-    val branchingRecord = branchingStack.head
-    assert(branchingRecord.id == uidBranchPoint)
-    // no close scope is inserted because branches are not considered scopes
-    branchingStack = branchingStack.tail
+    listener.endBranchPoint(this, uidBranchPoint)
   }
 
   /**
@@ -552,12 +581,15 @@ class SymbLog(v: ast.Member, s: State, pcs: PathConditionStack) {
     _macros = _macros + (m -> body)
   }
 
-  override def toString: String = new SimpleTreeRenderer().renderMember(this)
+  override def toString: String = listener match {
+    case log: InMemorySymbLog => new SimpleTreeRenderer().renderMember(log)
+    case _ => super.toString
+  }
 }
 
-object NoopSymbLog extends SymbLog(null, null, null) {
+object NoopSymbLog extends SymbLog(null, null, null, null) {
   override def openScope(s: DataRecord): Int = 0
-  override def insertBranchPoint(possibleBranchesCount: Int, condition: Option[Term]): Int = 0
+  override def insertBranchPoint(possibleBranchesCount: Int, condition: Option[Term], conditionExp: Option[Exp]): Int = 0
   override def switchToNextBranch(uidBranchPoint: Int): Unit = {}
   override def markReachable(uidBranchPoint: Int): Unit = {}
   override def closeScope(n: Int): Unit = {}
diff --git a/src/main/scala/logger/records/structural/BranchingRecord.scala b/src/main/scala/logger/records/structural/BranchingRecord.scala
index ea99e822..52876137 100644
--- a/src/main/scala/logger/records/structural/BranchingRecord.scala
+++ b/src/main/scala/logger/records/structural/BranchingRecord.scala
@@ -8,22 +8,23 @@ package viper.silicon.logger.records.structural
 
 import viper.silicon.logger.records.SymbolicRecord
 import viper.silicon.state.terms.Term
+import viper.silver.ast.Exp
 
-class BranchingRecord(possibleBranchesCount: Int, val condition: Option[Term]) extends StructuralRecord {
+class BranchingRecord(possibleBranchesCount: Int, val condition: Option[Term], val conditionExp: Option[Exp]) extends StructuralRecord {
   private var currentBranchIndex = 0
   private val branches: Vector[BranchInfo] = Vector.tabulate(possibleBranchesCount)(_ => new BranchInfo())
 
-  def appendLog(r: SymbolicRecord): Unit = {
-    assert(currentBranchIndex < branches.length)
-    val branch = branches(currentBranchIndex)
-    branch.records = branch.records :+ r
+  def getCurrentBranch: BranchInfo = {
+    assert(0 <= currentBranchIndex && currentBranchIndex < branches.length)
+    branches(currentBranchIndex)
   }
 
+  def appendLog(r: SymbolicRecord): Unit =
+    getCurrentBranch.records :+= r
+
   def markReachable(): Unit = {
-    assert(currentBranchIndex < branches.length)
-    val branch = branches(currentBranchIndex)
-    branch.isReachable = true
-    branch.startTimeMs = System.currentTimeMillis()
+    getCurrentBranch.isReachable = true
+    getCurrentBranch.startTimeMs = System.currentTimeMillis()
   }
 
   def switchToNextBranch(): Unit = {
diff --git a/src/main/scala/logger/renderer/Renderer.scala b/src/main/scala/logger/renderer/Renderer.scala
index 29b62174..d76c424e 100644
--- a/src/main/scala/logger/renderer/Renderer.scala
+++ b/src/main/scala/logger/renderer/Renderer.scala
@@ -9,5 +9,5 @@ package viper.silicon.logger.renderer
 trait Renderer[S, T] {
   def renderMember(s: S): T
 
-  def render(memberList: Seq[S]): T
+  def render(memberList: Iterable[S]): T
 }
diff --git a/src/main/scala/logger/renderer/SimpleTreeRenderer.scala b/src/main/scala/logger/renderer/SimpleTreeRenderer.scala
index cfd4589d..ffa96f80 100644
--- a/src/main/scala/logger/renderer/SimpleTreeRenderer.scala
+++ b/src/main/scala/logger/renderer/SimpleTreeRenderer.scala
@@ -7,15 +7,15 @@
 package viper.silicon.logger.renderer
 
 import scala.annotation.unused
-import viper.silicon.logger.SymbLog
+import viper.silicon.logger.InMemorySymbLog
 import viper.silicon.logger.records.SymbolicRecord
 import viper.silicon.logger.records.data.DataRecord
 import viper.silicon.logger.records.scoping.{CloseScopeRecord, OpenScopeRecord}
 import viper.silicon.logger.records.structural.{BranchingRecord, JoiningRecord}
 import viper.silicon.state.terms.Not
 
-class SimpleTreeRenderer extends Renderer[SymbLog, String] {
-  def render(memberList: Seq[SymbLog]): String = {
+class SimpleTreeRenderer extends Renderer[InMemorySymbLog, String] {
+  def render(memberList: Iterable[InMemorySymbLog]): String = {
     var res = ""
     for (m <- memberList) {
       res = res + renderMember(m) + "\n"
@@ -23,7 +23,7 @@ class SimpleTreeRenderer extends Renderer[SymbLog, String] {
     res
   }
 
-  def renderMember(member: SymbLog): String = {
+  def renderMember(member: InMemorySymbLog): String = {
     // val filteredLog = filterEmptyScopes(member.log)
     toSimpleTree(member.log, 0, 0)
   }
diff --git a/src/main/scala/logger/writer/SymbExLogReportWriter.scala b/src/main/scala/logger/writer/SymbExLogReportWriter.scala
index 96d24be4..40ba9cef 100644
--- a/src/main/scala/logger/writer/SymbExLogReportWriter.scala
+++ b/src/main/scala/logger/writer/SymbExLogReportWriter.scala
@@ -10,7 +10,7 @@ import spray.json.{JsArray, JsBoolean, JsNull, JsNumber, JsObject, JsString, JsT
 import viper.silicon.Map
 import viper.silicon.common.collections.immutable.InsertionOrderedSet
 import viper.silicon.interfaces.state.Chunk
-import viper.silicon.logger.SymbLog
+import viper.silicon.logger.InMemorySymbLog
 import viper.silicon.logger.records.scoping.{CloseScopeRecord, OpenScopeRecord}
 import viper.silicon.logger.records.structural.{BranchInfo, BranchingRecord, JoiningRecord}
 import viper.silicon.logger.records.{RecordData, SymbolicRecord}
@@ -107,19 +107,19 @@ object SymbExLogReportWriter {
     * @param members A symbolic log per member to translate.
     * @return array of all records.
     */
-  def toJSON(members: Seq[SymbLog]): JsArray = {
+  def toJSON(members: Seq[InMemorySymbLog]): JsArray = {
     val records = members.foldLeft(Vector[JsValue]()) {
-      (prevVal: Vector[JsValue], member: SymbLog) => prevVal ++ toJSON(member)
+      (prevVal: Vector[JsValue], member: InMemorySymbLog) => prevVal ++ toJSON(member)
     }
     JsArray(records)
   }
 
-  /** Translates a SymbLog to a vector of JsValues.
+  /** Translates a InMemorySymbLog to a vector of JsValues.
     *
     * @param symbLog The symbolic log to translate.
     * @return array of all records.
     */
-  def toJSON(symbLog: SymbLog): Vector[JsValue] = {
+  def toJSON(symbLog: InMemorySymbLog): Vector[JsValue] = {
     val allRecords = getAllRecords(symbLog.log)
     allRecords.map(toJSON).toVector
   }
diff --git a/src/main/scala/rules/Brancher.scala b/src/main/scala/rules/Brancher.scala
index c184a6e0..78a1273a 100644
--- a/src/main/scala/rules/Brancher.scala
+++ b/src/main/scala/rules/Brancher.scala
@@ -75,7 +75,7 @@ object brancher extends BranchingRules {
     v.decider.prover.comment(thenBranchComment)
     v.decider.prover.comment(elseBranchComment)
 
-    val uidBranchPoint = SymbExLogger.currentLog().insertBranchPoint(2, Some(condition))
+    val uidBranchPoint = SymbExLogger.currentLog().insertBranchPoint(2, Some(condition), conditionExp)
 
     val elseBranchVerificationTask: Verifier => VerificationResult =
       if (executeElseBranch) {
diff --git a/src/main/scala/verifier/DefaultMasterVerifier.scala b/src/main/scala/verifier/DefaultMasterVerifier.scala
index 0ee0df6e..8e699ef2 100644
--- a/src/main/scala/verifier/DefaultMasterVerifier.scala
+++ b/src/main/scala/verifier/DefaultMasterVerifier.scala
@@ -252,7 +252,7 @@ class DefaultMasterVerifier(config: Config, override val reporter: Reporter)
 
     if (config.ideModeAdvanced()) {
       reporter report ExecutionTraceReport(
-        SymbExLogger.memberList,
+        SymbExLogger.memberList.toIndexedSeq,
         this.axiomsAfterAnalysis().toList,
         this.postConditionAxioms().toList)
     }
