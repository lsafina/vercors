adt `seq`<T> {
  pure int seq_length(`seq`<T> xs);
  pure T seq_index(`seq`<T> xs, int i);
  pure boolean seq_contains(`seq`<T>, T t);
  pure int seq_idx_skolem(`seq`<T>, T t);

  pure boolean seq_equal(`seq`<T> xs, `seq`<T> ys);
  pure int seq_diff_skolem(`seq`<T> xs, `seq`<T> ys);

  pure `seq`<T> seq_empty();
  pure `seq`<T> seq_singleton(T t);
  pure `seq`<T> seq_concat(`seq`<T> xs, `seq`<T> ys);
  pure `seq`<int> seq_range(int min, int max);

  pure `seq`<T> seq_update(`seq`<T> xs, int i, T t);
  pure `seq`<T> seq_take(`seq`<T> xs, int n);
  pure `seq`<T> seq_drop(`seq`<T> xs, int n);

  pure `seq`<T> `seq_+`(int x, int y);
  axiom (∀int i, int j; `seq_+`(i, j) == i + j);
  pure `seq`<T> `seq_-`(int x, int y);
  axiom (∀int i, int j; `seq_-`(i, j) == i - j);

  // length and seq_empty/identity
  axiom (∀`seq`<T> xs; {:seq_length(xs):} >= 0);
  axiom seq_length(seq_empty()) == 0;
  axiom (∀`seq`<T> xs; {:seq_length(xs):} == 0 ==> xs == seq_empty());
  axiom (∀T t; seq_length({:seq_singleton(t):}) == 1);
  axiom (∀`seq`<T> xs, `seq`<T> ys; xs != seq_empty() && ys != seq_empty() ==>
    {:seq_length(seq_append(xs, ys)):} == seq_length(xs) + seq_length(ys));
  axiom (∀`seq`<T> xs, `seq`<T> ys;
    (xs == seq_empty() ==> {:seq_append(xs, ys):} == ys) &&
    (ys == seq_empty() ==> seq_append(xs, ys) == xs));
  axiom (∀`seq`<T> xs, int i, T t;
    0 <= i && i < seq_length(xs) ==> {:1:seq_length({:2:seq_update(xs, i, t):}):} == {:2:seq_length(xs):}
  );
  axiom (∀`seq`<T> xs, int n;
    n > 0
      ? {:1:seq_length({:2:seq_take(xs, n):}):} == ({:2:seq_length(xs):} >= n ? n : seq_length(xs))
      : seq_take(xs, n) == seq_empty()
  );
  axiom (∀`seq`<T> xs, int n;
    n > 0
      ? {:1:seq_length({:2:seq_drop(xs, n):}):} == ({:2:seq_length(xs):} >= n ? n : seq_length(xs))
      : seq_drop(xs, n) == xs
  );

  // index of builder
  axiom (∀T t; seq_index({:seq_singleton(t):}, 0) == t);
  axiom (∀`seq`<T> xs, `seq`<T> ys, int i;
    xs != seq_empty() && ys != seq_empty() && 0 <= i && i < seq_length(xs) ==>
      {:1:seq_index({:2:seq_concat(xs, ys):}, i):} == {:2:seq_index(xs, i):}
  );
  axiom (∀`seq`<T> xs, `seq`<T> ys, int i;
    xs != seq_empty() && ys != seq_empty() && seq_length(xs) <= i && i < seq_length(seq_concat(xs, ys)) ==>
      `seq_+`(`seq_-`(i, seq_length(xs)), seq_length(xs)) == i &&
      {:seq_index(seq_append(xs, ys), i):} == seq_index(ys, `seq_-`(i, seq_length(xs)))
  );
  axiom (∀`seq`<T> xs, `seq`<T> ys, int i;
    xs != seq_empty() && ys != seq_empty() && 0 <= i && i < seq_length(ys) ==>
      `seq_-`(`seq_+`(i, seq_length(xs)), seq_length(xs)) == i &&
      seq_index({:seq_concat(xs, ys):}, `seq_+`(i, seq_length(xs))) == {:seq_index(ys, i):}
  );
  axiom (∀`seq`<T> xs, int i, int ui, T t; 0 <= i && i < seq_length(xs) ==>
      (i == ui ==> {:1:seq_index(seq_update(xs, ui, t), i):} == t) &&
      (i != ui ==> seq_index({:2:seq_update(xs, ui, t):}, i) == {:2:seq_index(xs, i):})
  );

  // index of take/drop
  axiom (∀`seq`<T> xs, int i, int n;
    0 <= i && i < n && i < seq_length(xs) ==>
      {:1:seq_index({:2:seq_take(xs, n):}, i):} == {:2:seq_index(xs, i):}
  );
  axiom (∀`seq`<T> xs, int i, int n;
    0 < n && 0 <= i && i < seq_length(xs) - n ==>
      `seq_-`(`seq_+`(i, n), n) == i &&
      {:seq_index(seq_drop(xs, n), i):} == seq_index(xs, `seq_+`(i, n))
  );
  axiom (∀`seq`<T> xs, int i, int n;
    0 < n && n <= i && i < seq_length(xs) - n ==>
      `seq_+`(`seq_-`(i, n), n) == i &&
      seq_index({:seq_drop(xs, n):}, `seq_-`(i, n)) == {:seq_index(xs, i):}
  );

  // take/drop of update is update of take/drop
  axiom (∀`seq`<T> xs, int n, int i, T t;
    0 <= i && i < n && i < seq_length(xs) ==> {:seq_take(seq_update(xs, i, t), n):} == seq_update(seq_take(xs, n), i, t)
  );
  axiom (∀`seq`<T> xs, int n, int i, T t;
    n <= i && i < seq_length(xs) ==> {:seq_take(seq_update(xs, i, t), n):} == seq_take(xs, n)
  );
  axiom (∀`seq`<T> xs, int n, int i, T t;
    0 <= i && n <= i && i < seq_length(xs) ==> {:seq_drop(seq_update(xs, i, t), n):} == seq_update(seq_drop(xs, n), i-n, t)
  );
  axiom (∀`seq`<T> xs, int n, int i, T t;
    0 <= i && n > i && i < seq_length(xs) ==> {:seq_drop(seq_update(xs, i, t), n):} == seq_drop(xs, n)
  );

  // take/drop of concat is concat of take/drop
  axiom (∀`seq`<T> xs, `seq`<T> ys, int n;
    n > 0 && n <= seq_length(xs) ==> {:seq_take(seq_concat(xs, ys), n):} == seq_take(xs, n)
  );
  axiom (∀`seq`<T> xs, `seq`<T> ys, int n;
    n > 0 && n > seq_length(xs) ==>
      `seq_+`(`seq_-`(n, seq_length(xs)), seq_length(xs)) == n &&
      {:seq_take(seq_concat(xs, ys), n):} == seq_concat(xs, seq_take(ys, `seq_-`(n, seq_length(xs))))
  );
  axiom (∀`seq`<T> xs, `seq`<T> ys, int n;
    n > 0 && n <= seq_length(xs) ==> {:seq_drop(seq_concat(xs, ys), n):} == seq_concat(seq_drop(xs, n), ys)
  );
  axiom (∀`seq`<T> xs, `seq`<T> ys, int n;
    n > 0 && n > seq_length(xs) ==>
      `seq_+`(`seq_-`(n, seq_length(xs)), seq_length(xs)) == n &&
      {:seq_drop(seq_concat(xs, ys), n):} == seq_drop(ys, `seq_-`(n, seq_length(xs)))
  );

  // contains
  axiom (∀T t1, T t2; {:seq_contains(seq_singleton(t1), t2):} == (t1 == t2));
  axiom (∀`seq`<T> xs, T t;
    {:seq_contains(xs, t):} ==>
      0 <= seq_idx_skolem(xs, t) && seq_idx_skolem(xs, t) < seq_length(xs) && seq_index(xs, seq_idx_skolem(xs, t)) == t
  );
  axiom (∀`seq`<T> xs, T t, int i;
    0 <= i && i < seq_length(xs) && {:seq_index(xs, i):} == t ==> {:seq_contains(xs, t):}
  );

  // equal
  axiom (∀`seq`<T> xs, `seq`<T> ys; {:seq_equal(xs, ys):} ==>
    xs == ys && seq_length(xs) == seq_length(ys) &&
    (∀int i; 0 <= i && i < seq_length(xs) ==> {:1:seq_index(xs, i):} == {:2:seq_index(ys, i):})
  );
  axiom (∀`seq`<T> xs, `seq`<T> ys;
    (xs == ys && {:seq_equal(xs, ys):}) ||
    (xs != ys && !seq_equal(xs, ys) && seq_length(xs) != seq_length(ys)) ||
    (xs != ys && !seq_equal(xs, ys) && seq_length(xs) == seq_length(ys) &&
      seq_diff_skolem(xs, ys) == seq_diff_skolem(ys, xs) &&
      0 <= seq_diff_skolem(xs, ys) && seq_diff_skolem(xs, ys) < seq_length(xs) &&
      seq_index(xs, seq_diff_skolem(xs, ys)) != seq_index(ys, seq_diff_skolem(xs, ys)))
  );

  // range
  axiom (∀int min, int max;
    min < max
      ? {:seq_length(seq_range(min, max)):} == max-min
      : seq_range(min, max) == `seq`<int>.seq_empty()
  );
  axiom (∀int min, int max, int i; 0 <= i && i < max-min ==> {:seq_index(seq_range(min, max), i):} == min + i);
  axiom (∀int min, int max, int v; {:seq_contains(seq_range(min, max), v):} == (min <= v && v < max));
}